/*
 * Author : Sauce (CS13B056)
 * CS2810 - Advanced Programming Lab
 * Runner Class for implementing Ford-Fulkerson Algorithm
 */

import java.util.*;

public class Runner 
{
	//Maintains the current Path using a stack of edges.
	private static Stack<WeightedDirectedEdge> curPath;
	private static WeightedDirectedEdge bottleneckPipe = null;	
	public static void main(String[] args)
	{
		int n,m;
		Scanner in = new Scanner(System.in);
		curPath = new Stack<WeightedDirectedEdge>();
		n= in.nextInt();
		Graph graph = new Graph(n);
		m = in.nextInt();
		int sourceID, destID;
		int flowCapacity;
		WeightedDirectedEdge e;
		for(int i=0;i<m;i++)
		{
			sourceID = in.nextInt();
			destID = in.nextInt();
			flowCapacity = in.nextInt();
			e = new WeightedDirectedEdge(graph.vertices[sourceID],graph.vertices[destID],flowCapacity);
			graph.vertices[sourceID].adjacentNodes.add(e);
		}
		in.close();
		boolean flowSubOptimal = flowSubOptimal = findPath(graph.vertices[0], graph.vertices[n-1]);;
		int maxFlow = 0;
		while(flowSubOptimal)
		{			
			maxFlow += bottleneckPipe.flowCapacity;
			useAugmentingPath();
			flowSubOptimal = findPath(graph.vertices[0], graph.vertices[n-1]);
		}
		System.out.println(maxFlow);
	}
	
	//Finds a path between source and dest.
	public static boolean findPath(Vertex source, Vertex dest)
	{
		Vertex curVertex;
		for(WeightedDirectedEdge e : source.adjacentNodes)
		{
			curVertex = e.dest;
			curPath.push(e);
			
			//Terminating condition.
			if(curVertex.vertexID == dest.vertexID)
			{
				if(bottleneckPipe == null)
					bottleneckPipe = e;
				if(bottleneckPipe.compareTo(e) > 0)
					bottleneckPipe = e;
				System.out.println("found path.");
				return true;
			}
			System.out.print("Pushing : "+source.vertexID+"->"+e.dest.vertexID);
			//If you found a path, then return success.
			if(findPath(curVertex,dest))	
			{
				if(bottleneckPipe == null)
					bottleneckPipe = e;
				if(bottleneckPipe.compareTo(e) > 0)
					bottleneckPipe = e;
				return true;		
			}
			else
			{
				curPath.pop();
				System.out.print("Popping : "+source.vertexID+"->"+e.dest.vertexID);
			}
		}
		System.out.println(" ");
		//If you were unable to find a path, then return false.
		return false;
	}
	
	//Uses the path that's stored in curPath and makes a flow.
	public static void useAugmentingPath()
	{
		System.out.println("Clearing the augmenting path.ss");
		//Removes the edge that was bottleneck for the last iteration.
		bottleneckPipe.source.adjacentNodes.remove(bottleneckPipe);
		
		//Clears the path.
		curPath.clear();
		return;
	}
}
